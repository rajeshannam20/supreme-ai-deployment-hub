"""
AG-UI Listener implementation for Devon.AI.
This module provides endpoints for streaming tokens and handling tool results.
"""

from fastapi import APIRouter, Request, Depends, HTTPException
from fastapi.responses import StreamingResponse
from sse_starlette.sse import EventSourceResponse
import json
import asyncio
from typing import Dict, Any, AsyncGenerator, Optional
from pydantic import BaseModel

# Session storage - in production, use Redis or another persistent store
active_sessions: Dict[str, Dict[str, Any]] = {}

# Router configuration
router = APIRouter(prefix="/agui", tags=["agui"])


class ToolResultRequest(BaseModel):
    session_id: str
    tool_name: str
    result: Any


async def token_generator(session_id: str, prompt: str) -> AsyncGenerator[str, None]:
    """Generate tokens for an agent session."""
    # This is a mock implementation - in production, connect to your LLM orchestration layer

    # Start with thinking message
    yield json.dumps({"type": "thinking", "content": "Processing your request..."})
    await asyncio.sleep(1)

    # Example token stream - replace with actual integration
    tokens = [
        {"type": "token", "content": "I'll help you with that. "},
        {"type": "token", "content": "First, let me gather some information."},
        {"type": "tool", "toolName": "search_docs", "toolInput": {"query": prompt}},
        # After tool call, the agent would wait for tool result before continuing
        {"type": "token", "content": "Based on the information I found, "},
        {"type": "token", "content": "I can provide the following answer:"},
        {"type": "token", "content": f"Your query was about '{prompt}'. "},
        {"type": "token", "content": "This is a simulated response."},
        {"type": "done"},
    ]

    for token in tokens:
        # In a real implementation, you would integrate with LangGraph/CrewAI here
        yield json.dumps(token)
        await asyncio.sleep(0.5)  # Simulate token generation delay


@router.get("/stream-token")
async def stream_token(request: Request, session_id: str, prompt: str):
    """
    Stream tokens from the agent to the client.

    This endpoint sets up a Server-Sent Events (SSE) connection
    that streams tokens as they're generated by the agent.
    """
    if not session_id or not prompt:
        raise HTTPException(status_code=400, detail="Missing required parameters")

    # Initialize or update session data
    active_sessions[session_id] = {
        "prompt": prompt,
        "status": "active",
        "waiting_for_tool": None,
    }

    # Set up event stream for this client
    return EventSourceResponse(token_generator(session_id, prompt))


@router.post("/tool-result")
async def submit_tool_result(request: ToolResultRequest):
    """
    Submit the result of a tool execution back to the agent.

    This allows the agent to continue its reasoning with the tool's output.
    """
    session_id = request.session_id

    if session_id not in active_sessions:
        raise HTTPException(status_code=404, detail="Session not found")

    session = active_sessions[session_id]
    if session["status"] != "active":
        raise HTTPException(status_code=400, detail="Session is not active")

    # In a real implementation, you would pass this result to your
    # agent orchestration system (LangGraph/CrewAI) to continue processing

    # Update session data
    active_sessions[session_id]["last_tool_result"] = {
        "tool_name": request.tool_name,
        "result": request.result,
    }

    return {"success": True}


@router.delete("/session/{session_id}")
async def end_session(session_id: str):
    """End an agent session and clean up resources."""
    if session_id in active_sessions:
        active_sessions[session_id]["status"] = "completed"
        # In a real implementation, you would notify your agent system to stop processing

        # Clean up after a delay
        async def cleanup():
            await asyncio.sleep(60)  # Keep session data for 1 minute
            if session_id in active_sessions:
                del active_sessions[session_id]

        asyncio.create_task(cleanup())

        return {"success": True, "message": "Session ended"}
    else:
        raise HTTPException(status_code=404, detail="Session not found")
